# 2 Webサービス概要

## 2.1 Webサービスの定義

以下に当資料における「Webサービス」を定義します。

![2.1_Webサービスの定義.jpg](/files/2.1_Webサービスの定義.jpg)
<br>

Webメールやネットショッピング、SNSなど、インターネットで提供されるサービス全般を「Webサービス」と呼ぶ場合もありますが、ここではW3Cが定義した「**さまざまなプラットフォーム/フレームワーク上で動作する、異なるソフトウェア同士が相互運用するための標準的な手段を提供**」する標準技術を「Webサービス」と呼びます。

?> 「W3C」はWorld Wide Web Consortiumの略称。Web技術の標準化を行っている非営利団体。

<font siza="-2">
※ 「Web API (Application Programming Interface)」は「Webサービス」とほぼ同義で使われることがあるが、「プログラムから使用することを前提としたWebサービス」のニュアンスである場合が多いと思われる<br>
※ 似た用語に「OpenAPI」(旧Swagger仕様)があり、こちらは「RESTful Webサービス」のAPIを記述するインターフェース定義言語の仕様
</font>

Webサービスを利用すると、ネットワーク越しに情報を提供/取得する仕組みを、柔軟、動的、容易、かつ、低コストに構築できるようになります。

モダナイゼーションの促進、サービス提供/利用形態の多様化対応、既存システムのマイクロサービス化など、DX(デジタルトランスフォーメーション)を実現する手段としても、Webサービスは非常に有効でしょう。

<br>

## 2.2 Webサービスの要件

Webサービスは手段であり、目的ではありません。はじめに要求分析を行い、アプリケーション要件を検討・定義します。

機能要件、非機能要件の例には次のような項目が考えられます。

<u>機能要件</u>

* 新規に開発するか、既存のビジネスロジックを流用するか。
* 高機能なSOAP(＋XML)にするか、軽量でシンプルなREST(＋JSON)にするか。
* ツールやパッケージを利用するか、プログラミング言語で開発するか。
* クライアントとサーバーの通信に使う文字コード。
* その他、対応するクライアントの種類、ユーザーインターフェースの要否と機能、Webサービス関連機能の充足度、など。

?> 文字コードにユニコード(UTF-8)を採用するWebサービスが多いが、IBM iのデフォルト文字コードはEBCDIC。Db2 for iやILE言語でUTF-8を利用する場合は指定が必要。

<u>非機能要件</u>

* Webサービスを構成するコンポーネントの、製品としての保証、サポート、ライフサイクル、前方/後方互換性。
* 構築したWebサービスの信頼性/サービス・レベル、パフォーマンス、運用・保守。
* Webサービスを開発する要員のスキル、開発生産性、保守容易性。
* その他、暗号化や認証などのセキュリティ、拡張性、耐障害性、安定性、システムライフ、可搬性、など。

検討の結果として、BSC(音声電話回線)、FTP、MQ(メッセージ・キューイング)、DRDA(分散データベース)、CORBAなど、従来の手法が適しているという結論もあり得ます。

Webサービスは万能ではないのでその特性を考慮し、やることとやらない(既存の仕組みで実装する)ことを判断すべきでしょう。

<br>

当資料はWebサービスそのものの詳細には立ち入りませんが、この節で基本的なポイントをいくつか解説します。

<br>

### 2.2.1 SOAP/XMLとREST/JSON

Webサービスは2000年代初頭から注目を集めましたが、利用の広まりは限定的でした。これは、通信プロトコルであるSOAPの仕様が複雑で、敷居が高かったことが理由の一つと推測されます。2010年代以降は、SOAPよりも軽量でシンプルなRESTアーキテクチャーを採用するケースが増加し、Webサービスの普及が進展しています。

?> SOAPはWebサービスで使用されるメッセージのデータフォーマットや、メッセージの処理ルールを定めた通信規約の一つ。元はSimple Object Access Protocolの頭字語とされていたが、現在は「何かの頭字語ではない」とされている

下のグラフは、Google TrendsでWebサービスに関連した用語である「SOAP」、「XML」、「REST」、「JSON」の、検索人気度の推移をあらわしています。

* SOAPは2000年台前半に最も人気度が高く、その後は漸減して2010年台はほぼ一定の値。XMLも同様に、人気度は低落傾向
* REST/JSONは年々人気度をあげており、現在はSOAP/XML以上の人気度

![2.2.1_SOAP_XMLとREST_JSON.jpg](/files/2.2.1_SOAP_XMLとREST_JSON.jpg)

<font size="-2">
※ 2021/4時点のGoogle Trends (https://trends.google.co.jp/trends/?geo=JP )の結果<br>
※ ｢SOAP｣｢Representational State Transfer｣の比較と「Extensible Markup Language｣｢JavaScript Object Notation｣の比較を合成<br>
※ ｢人気度｣の数値はグラフ上の最高値を基準として検索インタレストを相対的に表したもの
</font>

SOAP/XMLは今も主としてエンタープライズ用途で利用されており、SNS等で広く使われているREST/JSONとは今後も住み分けると思われます。

<br>

### 2.2.2 Webサービス(REST)の仕組み

RESTアーキテクチャーに基づくWebサービスのイメージを下図に示します。

?> もともと「REST」(Representational State Transfer)は概念モデル、あるいは、アーキテクチャーであり、SOAPのような仕様/プロトコルとは異なる。この概念モデルに基づいて既存のWeb技術(プロトコルにHTTP、リソース/操作の指定にURI、送受信データ形式にJSON、など)を組み合わせた仕組みが、狭義のRESTといえる。

![2.2.2_Webサービス(REST)の仕組み.jpg](/files/2.2.2_Webサービス(REST)の仕組み.jpg)

<br>

大まかな処理の流れは次のようになります。

?> 日本のWikipediaではRESTの原則として4項目を挙げている。英語版のWikipediaや原典の定義とは分類が異なっているので必要な場合は認識の統一を推奨。<br>・ステートレスなクライアント/サーバプロトコル<br>・すべての情報(リソース)に適用できる「よく定義された操作」のセット<br>・リソースを一意に識別する「汎用的な構文」<br>・アプリケーションの情報と状態遷移の両方を扱うことができる「ハイパーメディアの使用」

① Webサービスのクライアント(あるいは、リクエスター、コンシューマー)は、リクエストをURIの一部やTEXT/JSONなどの形式で用意

② URIで表されたリソースに対して、GETやPOSTなどのHTTPメソッドでWebサービスのサーバーにリクエストを送信

③ サーバーは要求されたURI、HTTPメソッド、送られてきたデータを解析。リクエストに基づき、例えばデータベースに対して、データの作成、読取、更新、削除、などの操作を実行

④ 結果をテキストやJSON形式でHTTP応答と合わせてクライアントに送信

<br>

REST WebサービスではHTTP(Hypertext Transfer Protocol)でクライアントがサーバーに要求を行います。このリクエストの種類により、いくつかHTTPの「メソッド」が用意されています。

?> RFC 7231(https://datatracker.ietf.org/doc/html/rfc7231 )ではGET、POST、PUT、DELETE、HEAD、OPTIONS、TRACE、CONNECTの8つのメソッドを定義。

一般的に、主要なHTTPメソッドとWebサービス処理の対応は次のようになります。これらのメソッドはCRUDの基本機能にマッピングされます。なお、これらのメソッドの中でPOST(Create)のみが冪(べき)等ではありません。

?> CRUDは永続的なデータを取り扱うソフトウェア、あるいは、データベース管理システムに必要とされるCreate、Read、Update、Deleteの基本4機能の頭文字をとった用語。

?> 「冪等」は数学用語で、特定の操作を1回行っても複数回行っても同じ結果が得られる性質。

|メソッド|HTTPの動作|Webサービス処理|CRUD|
|-------|----------|--------------|----|
|GET|指定したURIのリソースを取得してクライアントに送信|指定されたデータを返す|Read|
|POST|クライアントから情報をHTTPサーバーに送信|指定されたデータを追加|Create|
|PUT|指定のURIにリソースを保存|指定されたデータを更新(作成または置換)|Create/Update|
|DELETE|指定したURIのリソースを削除|指定されたデータを削除|Delete|

<br>

Webサービスの設計では、URIが同一(例えば「/persons」)であっても、メソッドがGETであれば「登録者情報を返す」処理を、メソッドがPOSTであれば「登録者を追加する」処理を行ないます。例えば下表は「Best Practices for Designing a Pragmatic RESTful API」(https://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api )から作成したものです。

|リソース|GET|POST|PUT|DELETE|
|--------|---|----|---|------|
|/tickets|チケットのリストを取得|新しいチケットを作成|-|-|
|/tickets/12|指定したチケットの情報を取得|-|チケット12を更新|チケット12を削除|

<br>

Web APIのベスト・プラクティスとして、「URIに動詞を使わない」、「エンドポイントの名前は複数形にする」、「URIにバージョンを含めない」などがよく指摘されます。これらを全て鵜呑みにせず、RESTアーキテクチャーの目的に沿った、持続性・一貫性のある設計を考慮すべきでしょう。

<br>

### 2.2.3 JSON形式の基本

JSONは「JavaScript Object Notation」の略で、JavaScriptのオブジェクト記法に沿ったテキストベースのデータ記述言語です。名前が示すように元々はJavaScriptのオブジェクト表記法ですが、XMLと同様にデータ交換や各種設定の記述などに広く利用されています。

JSONとXMLはいずれもテキストベースの階層データ表現形式であり、用途も重複しています。これらを大まかに比較したのが次の表です。

![2.2.3_JSON形式の基本.jpg](/files/2.2.3_JSON形式の基本.jpg)

?> XMLの用途で、例えばMicrosoft Officeなどで作成される拡張子docx、.xlsx、および、pptxなどのファイルは、ISO/IECで標準化された「Office Open XML」という「ZIP圧縮されたXMLファイル群」というフォーマット。

<br>

日本ではデータ交換形式にCSVが広く利用されていますが、今後はWebサービス化に合わせてJSONに移行するケースも増えるでしょう。IBM iでこれらのフォーマットを使用する際に利用できる機能例を下表に示します。(ベンダー製品を除く)

| | |CSV|JSON|XML|
|-|-|---|----|---|
|IBM i|OS機能|CPY[TO\|FRM]IMPF|||
|     |Db2 for i (SQL)||JSON_TABLE表関数など多数|XMLTABLE表関数など多数|
|     |ライセンス・プログラム|ACSのデータ転送や<br>SQLスクリプト|||
|     |ILE-RPG|||XML-SAX命令など|
|     |ILE-COBOL|||XML PARSE命令など|
|OSS  |ツール||jqなど|xmllintなど|
|     |プログラミング言語|Pythonなど多くの<br>主要言語が各種ファイルの<br>処理機能を<br>基本機能や<br>外部パッケージで<br>実現|←|←|

Db2 for iのSQLを利用すれば比較的容易にJSONやXMLの処理が可能です。例えば、次のようなSQL文でテーブル「PERSON」(レイアウトは「4 Webサービス・サーバー」参照)から前のページの「例」にあるJSON/XMLが生成できます。

**(JSONの生成)**

```sql
SELECT 
    JSON_OBJECT('customer' VALUE 
        JSON_ARRAYAGG(
            JSON_OBJECT('custNo' VALUE REGNO, 
                        'custInfo' VALUE 
                JSON_OBJECT(
                    'custNameKj' VALUE TRIM(KJNAME),
                    'custNameKana' VALUE TRIM(KNNAME),
                    'custAddr1' VALUE TRIM(ADDR1),
                    'custAddr2' VALUE TRIM(ADDR2)
                )
            )
        )
    ) AS JSONOUT
  FROM WEBSXXLIB.PERSON
  WHERE KNNAME LIKE 'ｱｵ' || '%'
;
```

**(XMLの生成)**

```sql
SELECT 
    XMLSERIALIZE(
        XMLELEMENT(NAME "customer", 
            XMLAGG(
                XMLELEMENT(NAME "custInfo", 
                    XMLATTRIBUTES(RTRIM(REGNO) AS "custNo"),
                    XMLFOREST(
                        RTRIM(KJNAME,'　 ') AS "custNameKj",
                        CAST(RTRIM(KNNAME) AS VARCHAR(100) FOR MIXED DATA) 
                                            AS "custNameKana",
                        RTRIM(ADDR1,'　 ') AS "custAddr1",
                        RTRIM(ADDR2,'　 ') AS "custAddr2"
                    )          
                ) 
            ) 
        ) AS CLOB(1G) INCLUDING XMLDECLARATION
    ) AS XMLOUT
  FROM WEBSXXLIB.PERSON
  WHERE KNNAME LIKE 'ｱｵ' || '%'
; 
```

<br>

### 2.2.4 Webサービスと文字コード

Webサービスで使用するデータの多くは、文字コードにユニコード(UTF-8)を採用しています。一方、IBM iのネイティブ文字コードはEBCDICであり、ユニコードとは互換性がありません。

様々な文字種について、ユニコード、EBCDIC、ASCIIコード、それぞれの内部表現は下表の様になります。

?> IBM iは5桁のCCSID(コード化文字セットID)で内部コードが示す「文字」を特定する。表中のCCSIDは、それぞれ、1200→UTF-16、1399⇢日本語英小文字EBCDIC(JIS2004対応)、5026⇢日本語カタカナEBCDIC、437⇢US-ASCII、819⇢ISO-8859-1(Latin-1)、943⇢シフトJIS、を表す。なお、UTF-8のCCSIDは1208。詳細はIBM Docsの「CCSID の値」(https://www.ibm.com/docs/ja/i/7.5?topic=reference-ccsid-values )を参照。

![2.2.4_Webサービスと文字コード.jpg](/files/2.2.4_Webサービスと文字コード.jpg)

内部コードが全く異なる(変換テーブルが必要)事に加え、次のような差異があります。

* 内部コードでソートした際に並びが異なる(ASCIIは数値⇒文字、EBCDICは文字⇒数値の順)
* 変換不能(変換先で定義されていない)文字がある(表中<font color="red">赤字</font>)
? 1文字に対して割り当てられるバイト数が異なる(漢字、ユニコードの半角カタカナなど)

<br>

特に文字セットの差異が情報の欠落要因となる場合は考慮が必要でしょう。日本語に関連した主要文字コード規格の包含関係は下図のようになります。

![2.2.4_Webサービスと文字コード2.jpg](/files/2.2.4_Webサービスと文字コード2.jpg)


IBM iユーザーのほとんどは出荷時値のCCSID 5026を利用しており、これはWindows 3.1J相当の文字セットになります。Webサービスでやり取りする文字データを処理する場合の選択肢を考えてみましょう。

① ユニコード(UTF-8)に統一：変換処理のオーバーヘッドや文字化け・欠落がなく、最も望ましい。ただし、既存のDBやアプリケーションと連携する場合は、選択肢②と同様の考慮が必要。

② ユニコード(UTF-8)とEBCDIC(CCSID 5026/5035/1399)で相互に変換：EBCDICからユニコードへの変換で問題になる点 は少ない。逆の、ユニコードからEBCDICに変換する際には文字の欠落が発生。その場合下記のような対応が考えられるが一長一短。

?> EBCDICからユニコードへの変換では「代替CCSID 1399変換」(https://www.ibm.com/docs/ja/i/7.5?topic=information-alternative-ccsid-1399-conversion )のような互換性問題が存在

  * エラーとして拒否、あるいは再送を要求
  * 欠落文字を代替文字(「?」や「〓」など)に置き換え
  * 欠落の発生都度、ユーザー定義文字として登録
  * ユニコードエスケープ形式(\uxxxx)に変換して記録し、必要な場合はユニコードまたは外字、画像で表示

  ?> 例えば「𠮷野家」の「𠮷」(通称「つちよし」。部首の上が士ではなく下が長い土)はJISで規定されていない。「国税庁 法人番号公表サイト」(https://www.houjin-bangou.nta.go.jp/ )では、検索結果は「吉」で表示し、「>外字」をクリックした場合に「つちよし」を使った画像を表示して対応。

③ 既存の制限された文字セットに統一：例えば「JIS90で規定された文字」に限定。

<br>

Webサービスで文字データが適切に処理されるよう、事前の検討とテストをお勧めします。

<br>

## 2.3 IBM iのWebサービス実装

下図はIBM iで利用できる主なWebサービス実装手法を示しています。IBM iではこれらの多種多様な手法で、要件に合わせたWebサービスが構築できます。

![2.3_IBM_iのWebサービス実装.jpg](/files/2.3_IBM_iのWebサービス実装.jpg)

<font size="-2">
※ IBM i 7.4に2021年6月時点の最新TR/PTFを適用した構成に基づく<br>※ 記載以外にも、JavaやC/C++、PHP、Rubyなどの言語が利用可能<br>※ 非IBMのツール/商用ソフトウェアを除く
</font>
<br>

**HTTPサーバー** ：クライアントの要求を受け付けてWebサービスのサーバーに転送したり、CGIプログラムを呼び出したりして、結果をクライアントに返します。

**IWS(統合Webサービス)** ：ILEプログラムのビジネスロジックをサービスとして外部化するプロセスを大幅に簡素化します。最新のIBM iでは、ウィザード形式でWebサービス・サーバーを生成できます。さらに、ILE用のWebサービス・クライアントを作成するためのツールやAPIを提供します。

**SQL(Db2 for i)** ：XML/JSONの解析やDb2との連携のみならず、HTTPリクエストを発行するプロシージャーなど、多岐にわたるWebサービス機能を提供します。HTTP通信やJSON処理の機能を持たない言語でも、SQLが利用できればWebサービスを実装できます。

**ILE-RPG/COBOL** ：環境変数の値の取得や、標準入出力の利用など、限定的なWebサービス関連機能を提供します。実際には、IWS/IHS/SQLや外部ライブラリーなどと連携してWebサービスとして実装する事になるでしょう。

**Node.js/Python** ：Webサービス関連機能が充実しており、容易にWebサービスを実装できます。各言語用のWebフレームワークを利用して、開発工数を削減し、信頼性/保守性を向上させることも可能です。

<br>

### 2.3.1 Webサービス・クライアント実装

Webサービス・クライアントの具体的な実装には下表の手法が考えられます。

| |カテゴリ|実装|概要|開発の考慮事項|
|-|--------|----|----|------------|
|Ⓐ|ツール|PASEのcurlコマンド|コマンドラインからhttp要求を実行して結果を表示。主にテストに利用。CSVオプションやdb2コマンドを利用してデータをDBに登録する事なども可能|コーディング無し|
|Ⓑ||他ホスト(PCなど)のWebブラウザ|主たるWebサービスの用途がブラウザからの利用である場合に使用。XML/JSONデータはJavaScriptからAjaxのfetch()などを呼び出して送信|単純なGETメソッド以外でJavaScript、Ajaxのスキル要|
|Ⓒ|ILEプログラム|ILE-RPGなど、SQLを発行可能な言語|組み込みSQLのHTTP機能でhttpリクエストを発行し、結果をJSON_TABLE表関数で解析･利用|SQLが主要な処理を実行|
|Ⓓ||ILE-RPG/C＋Transport API＋パーサ＋α|Transport API群(ベースはApache Axis)でhttpリクエストを発行、JSON/XML/その他の送受信データは自前 で構築/デコード/パース|IBMのJSONPARSEは｢as-is｣で提供|
|Ⓔ|PASEスクリプト|Python、PHP、Node.jsなど|各種スクリプトから、httpリクエストとJSON/XMLなどのパース機能などを利用、必要に応じて拡張機能を追加|Linuxなど他プラットフォームとほぼ同様のコーディング|
|Ⓕ|その他|Java、C/C++など|IBM i以外のプラットフォームと同様にアプリケーションを作成|(同上)|

<br>

IBM iからバッチで外部のWebサービスからデータを取得する場合、前提ソフトウェア、IBMサポートの有無、開発者のスキル、実装の難易度、既存アプリとの親和性などを考慮すると、手法Ⓒが候補になるケースが多いでしょう。

手法Ⓓは各種APIと関連技術の理解と応用が必要であり、ハードルが高いと思われます。

?> 海外では「ez4WebServ」(https://www.easy400.net/ez4webserv/html/page1.htm )、「YAJL」(https://www.scottklement.com/yajl/) などのツールが公開されている(日本語対応は不明)。なお、データのパースに「XML-INTO」や「DATA-INTO」命令が用意されているが、パーサーは個別に開発が必要。詳細は「DATA-INTO opcode - new for 7.2 and 7.3 with PTFs」(https://www.ibm.com/support/pages/data-opcode-new-72-and-73-ptfs )などを参照。

PythonやNode.jsなどの言語はWebサービスに関連した拡張機能が豊富であり、HTTP通信やJSON処理を難なくこなせます。PASEとオープンソースに熟達した開発要員が確保できるのであれば、手法Ⓔも検討対象に入ります。

<br>

要件と照らし合わせ、適切なクライアント実装手法を選定しましょう。

<br>

### 2.3.2 Webサービス・サーバー実装

下表は、IBM i上でのWebサービス・サーバーの実装パターンを例示しています。

| |HTTPサーバー|Webアプリケーション|メリット|デメリット|ユースケース|
|-|-----------|------------------|-------|---------|-----------|
|➀|HTTP Server for i (IHS)|IWS (SQL)|作成が非常に簡単･迅速|細かい設定は不可。SQL外の処理の実装が困難|特定の入出力フォーマットを許容。実装速度と容易さを優先|
|②||IWS (ILE-RPG)|RPGスキルを活用、データの解析をIWSが実施|IWSの仕様に合わせたコーディングが必要|特定の入出力フォーマットを許容。ILE-RPG採用が要件|
|③||CGI (ILE-RPG)|ILE-RPGのスキルを活用、実行環境の構築が容易|データの解析/構築を自前で用意する必要あり|パフォーマンス重視、ILE-RPG採用が要件|
|④||PASE CGI (Python)|PythonとPyPIリポジトリの機能を活用可能|CPU消費が大きい。他の実装の数十倍の応答時間|高密度･大量･低遅延の要件が無い。Pythonの機能を活用|
|⑤|IHS＋FastCGI|WSGI (Python)|PASE CGI (Python)より高速。WSGIの活用可能|構成が複雑。WSGI仕様に則ったコーディングが必要|Pythonの機能を活かしつつ、CGIより応答時間を短縮|
|⑥|Express (Webフレームワーク)|Node.js|Node.js単体で動作。RESTとの親和性が高い|死活監視など運用を考慮。非同期プログラミング要|高密度･大量のリクエスト対応が必要。Nodeの機能を活用|

<br>

Webサービス・クライアントと観点を変え、それぞれのメリット、デメリット、そしてユースケースを考察しましょう。

手法➀は、細かい仕様を特定せず、コーディングレスで早期にWebサービスを実装する用途に最適です。本番業務はもちろん、PoC(概念実証)、Webサービスのスタブ、回線帯域の検証などで非常に有用でしょう。

手法②はRPG/COBOLの既存のビジネスロジックをWebサービスとして展開することが容易です。IWSがHTTPメソッド毎のルーティングや、入出力(URIやJSON)のフォーマット変換を行うので、コード量も少なくなります。

手法③はパフォーマンスの良いWebサービスをILE-RPGやCOBOLで記述できます。URIの解析とルーティングや、JSON形式のデータ処理を、プログラム側で行う必要があるので、難易度は高いでしょう。

手法④は少量・低密度のリクエストに対し、Pythonの機能を活用したWebサービスが構築できます。多数の拡張機能が無償で入手可能であり、IBM iアプリケーションの適用範囲を大きく広げることができます。

手法⑤は、FastCGIの構成とWSGIに副ったコーディングが必要なため、手法④でパフォーマンスが不足する場合に検討すると良いでしょう。表中には記載していませんが、PythonのWebフレームワークを利用すれば、高機能・高品質なWebアプリケーションの開発が効率よく実施できるでしょう。

?> WSGI (Web Server Gateway Interface)は「PEP 3333 – Python Web Server Gateway Interface v1.0.1」で定義された、WebサーバーとPython Webアプリケーションとの標準インターフェース。

手法⑥はDb2 for i のデータやNode.jsの機能を利用したWebサービスを、高速にクライアントに提供できます。非同期処理に対応したコーディングには慣れが必要ですが、ネット上の情報も豊富なので、オープンソース・ソフトウェア活用の端緒としても非常に効果的です。

<br>

下表は主観を交えて別の角度(環境構築の難易度、開発難易度、パフォーマンス)から比較した例です。必要に応じて比較項目を設定し、自組織の要件に照らして各手法を評価します。


| |HTTPサーバー|Webアプリケーション|DBアクセス|概要|環境構築|開発難易度|パフォーマンス|
|-|-----------|------------------|---------|----|-------|---------|-------|
|➀|HTTP Server for i (IHS)|IWS (SQL)|SQL (JDBC)|｢IBM Web Administration for i｣から｢Web Servicesサーバーの作成｣を選択し、ウィザード形式でSQL/ILEモジュールを選択して作成|容易|コーディング無し良好|
|②||IWS (ILE-RPG)|レコードI/Oまたは組み込みSQL|↑|↑|CGIとILE-RPGのスキルが必要|良好|
|③||CGI (ILE-RPG)|↑|従来型のCGIプログラムにWebサービス対応のロジックを追加|↑|↑|最良|
|④||PASE CGI (Python)|SQL (ODBC)|IHSからPASE環境のCGIスクリプトを呼出して実行|やや難|容易|重い|
|⑤|IHS＋FastCGI|WSGI (Python)|↑|PythonスクリプトをWSGI対応の記述にしてFastCGIと連携|難|やや難|やや重い|
|⑥|Express (Webフレームワーク)|Node.js|↑|ExpressとNode.jsの非同期処理を活用してREST Webサービスを実装|容易|容易|良好|


初めてWebサービスを実装するのであれば、まずは手法➀でPoC的にWebサービスを動かして要件の充足度を洗い出し、これをベースにして他の手法と比較・検討すればスムースに進められるでしょう。

<br>

### (参考) Webサービス・サーバーのパフォーマンス

このグラフは各手法で構築したWebサービス・サーバーに対し、Apache BenchをVPN接続のWindowsから実行した例です。厳密な比較ではないので、あくまでも参考としてご覧ください。

?> XAMPP(https://www.apachefriends.org/jp/index.html )付属のabコマンドをVPN接続のWindowsから実行。URIで指定された条件でDBを検索し、結果をJSONで返すWebサービスを、総リクエスト数100、同時アクセス数10で実行(ab -n 100 -c 10 <i>GETメソッドのurl</i>)。

![参考_Webサービス・サーバーのパフォーマンス.jpg](/files/参考_Webサービス・サーバーのパフォーマンス.jpg)

左のグラフが全てのリクエストの平均応答時間を、右のグラフが特定の時間内に処理されたリスクストの割合を表しています。

左のグラフではPythonを使用したPASE CGIの平均応答時間が0.5秒弱で他の手法より長くなっています。一般に数秒程度の応答時間が許容されるWebアプリケーションでは問題になる事は少ないと思われますが、数百クライアントが同時接続する、あるいは、高速のマイクロサービスが大量のリクエストを発行する、などの用途には、TornadoのようなWebフレームワーク/非同期通信ライブラリーが必要かもしれません。

右のグラフを見ると、いずれの手法も応答時間のばらつきが小さく、リクエストの90%近くまでほぼ一定の応答時間になっています。

<br>

どの手法も同時アクセス数(スレッド数)が一定数を超えるとエラーが発生し始めます。大量・高密度のWebサービスを実装する場合、DBアクセスの最適化、アクセス制限、ロードバランシングなどの採用を検討します。環境、構成、処理内容、同時アクセス数などによって結果は変動するため、必要な場合は実環境での検証をお勧めします。
